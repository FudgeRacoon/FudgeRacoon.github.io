<!DOCTYPE html>
<html lang="en">
    <head>
        <!--Title-->
        <title>Quad Tree</title>
        
        <!--Meta Tags-->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <!--Fonts-->
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Ubuntu&display=swap" rel="stylesheet">

        <!--Icons-->
        <link rel="icon" href="Icon/Icon.png" type="image/x-icon">
        
        <!--Scripts-->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/parallax/3.1.0/parallax.min.js"></script>
        <script src="Libs/p5.js"></script>

        <!--StyleSheet-->
        <link rel="stylesheet" type="text/css" href="Styles/QuadTree.css">
    </head>

    <body oncontextmenu="return false;">  

        <header>
            <section class="title">
                <h1>Quad Tree</h1>
            </section>
            <section class="info">
                <a href="index.html">Fudge's Tutorials</a>
            </section>
        </header>
        
        <div class="container-1">
            <section>
                <p>
                    Since the dawn of the first video game, collision has always been a part of any game created.
                    Lots of collision algorithms are out there, some are easy to master and some are not. However, any collision
                    system implemented must have some way to check if the interaction between two objects actually occurs. Checking
                    for collisions between a few objects in a scene is relatively easy. Altough, when it comes to checking for collision
                    between hundreds, or even thousands of objects using the dreaded pairwise comparison, that will take a great toll on
                    performance. Luckily, there exists many collision checks that offer efficiency and speed. One of which is the quad tree
                    data structure.
                </p>
            </section>

            <section>
                <header>
                    <h3>What is a quad tree</h3>
                </header>

                <p>
                    A quad tree is a tree data structure used in spatial partitioning, so that it's easy to traverse
                    and search. You may be wondering what exactly is spatial partitioning? To put it in simple terms,
                    spatial partitioning is the process of subdiving a scene into multiple regions, and that is exactly
                    what a quad tree does. It recursivly subdivids a game's world into smaller and smaller sections.
                    Generally, a quad tree must fulfill a certain criteria where each non-leaf node must have four children,
                    every leaf node has a maximum number of objects and if that number is exceeded the node is split.
                </p>

                <div class="scene">
                    <img src="Images/Quad_Tree/Block_1/Nodes.png" data-depth="0.5">
                </div>

                <p>
                    An important point to keep track of is that the leaf nodes only store data, while the parent nodes
                    store info on how to get to their children. As seen in the above diagram, the root node reached the
                    maximum number of objects allowed to be stored therefore it has split creating four children each 
                    holding the objects according to their postion in the world.
                </p>
            </section>

            <section>
                <header>
                    <h3>How does a quad tree work</h3>
                </header>

                <p>
                    As mentioned above, the whole purpose of a quad tree is to subdivide the world and arrange objects in that
                    world in various nodes. But why do we subdivide exactly and how is it done? The whole premise of subdivision
                    is to group objects that are close to each other and have a high possibility to collide with one another. This 
                    ultimately reduces the number of checks needed and in return boosts performance. Any quad tree starts with a root
                    node holding the scene boundry and all the objects inside that scene, once the number of objects exceed the node's
                    limit the boundry is divided into quadrants. Each quadrant is held by it's respective node and all objects that where
                    held by the parent node in our case the root will be checked by each child node if they are within their boundries or not,
                    if true then they're transfered if false the other nodes will be checked.
                    <br>
                    <br>
                    <strong>Press the left mouse button</strong> to draw a point in the scene below or the <strong>right mouse button</strong> 
                    to remove a point from the tree, and <strong>adjust the slider</strong> to configure the maximum number of points a single 
                    node can hold. <strong>Press the reset button</strong> if you want to start over.
                </p>

                <div class="drawing-container">

                </div>

                <p>
                    So, how do we implement this? To build a quad tree we first need to create a root node. A quad tree node consists of an array
                    that stores the objects, a pointer to it's four children and it's boundary. It's only a few lines in C++.
                </p>

                <div class="code-snippet">
                    <img src="Images/Quad_Tree/Block_2/QuadTreeNode_Snippet.png">
                </div>

                <p>
                    Now that the node class is done, we need to actually start implementing the quad tree itself. A quad tree has three important functions.
                    Insert, Update, and query. We'll start by creating core functions for the quad tree and then we'll get into the more important functions.
                </p>

                <div class="code-snippet">
                    <img src="Images/Quad_Tree/Block_2/QuadTree_Snippet.png">
                </div>

                <p>
                    First, we'll create a quad tree class that holds a root node, the current and maximum depth to prevent the tree from infinitly recursing
                    if objects are too close to each other and an array to hold the smallest quadrants. Now onto the functions.
                </p>

                <div class="code-snippet">
                    <img src="Images/Quad_Tree/Block_2/QuadTreeUtils_Snippet.png" >
                </div>

                <p>
                    <em>IsLeaf</em> and <em>InBoundary</em> are two important functions that will be used in the insert function. They're pretty much self explanatory.
                    The first function checks if the node passed is a leaf or not by checking its children, and the second function checks if the object's position is 
                    within the node's boundary.
                </p>
            </section>

            <section>
                <header>
                    <h3>Insertion and removal</h3>
                </header>

                <p>
                    Inserting and removing objects in and out of a quad tree is fairly simple. As discussed earlier non leaf nodes can not
                    store objects they only store data on how to get their children, also we have to keep in mind that once a node reaches 
                    it's maximum number of objects held it should subdivide. So, let's see how to implement this.
                </p>

                <div class="code-snippet">
                    <img src="Images/Quad_Tree/Block_3/QuadTreeSplit_Snippet.png">
                </div>

                <p>
                    The insert function requires a split function to be called once the maximum is reached. Essentially, what happens here is 
                    we take the minimum and maximum points of the boundary (A minimum point of a rectangle is the top left point and the maximum 
                    point is the bottom right point), afterwards we divide the max points which are in reality the width and height by two to get equal
                    quadrants and store them in the quadrants array. Just like that we have equal quadrants that are ready to be stored in their respective
                    nodes. Finally, we need to implement the insert function.
                </p>

                <div class="code-snippet">
                    <img src="Images/Quad_Tree/Block_3/QuadTreeInsert_Snippet.png" style="width: 100%;">
                </div>

                <p>
                    If you haven't noticed already we're using BFS (Breadth first search) to traverse the tree and insert an object in it's appropriate node.
                    We start by declaring a queue, then enqueuing the root node to that queue. Afterwards, we dequeue the node inline and check if the object 
                    we passed is a leaf, is within it's boundary and has capacity to store one more object if all these conditions are valid then we can insert.
                    However, if all conditions satisfy our statment but the object is not within the node's boundary then we grab another node from the queue.
                    As you guessed it, if the node is not a leaf then we enqueue all it's children. Now, comes the tricky part. What if the node is a leaf and the
                    object is within it's boundary but maximum capacity has been reached? This is when we call the split function and recursivly call the Insert function
                    to insert all the current node's elements into it's children. Keep in mind, before we split we need to check if the maximum depth has been reached. If
                    so we simply return, that way we ensure that the tree can no longer subdivide itself. 
                </p>
            </section>
        </div>

       <footer>
           <h3>&copy; Copyright 2021 FudgeRacoon</h3>
       </footer>

       <!--Scripts-->
       <script src="Scripts/Geometry.js"></script>
       <script src="Scripts/queue.js"></script>
       <script src="Scripts/quadTree.js"></script>
       <script src="Scripts/quadTreeVisulization_1.js"></script>
       
       <script type="text/javascript">
            let scenes = document.getElementsByClassName("scene");
            
            for(let scene of scenes)
            {
                let parallaxInstance = new Parallax(scene);
            }
       </script>

    </body>
</html>